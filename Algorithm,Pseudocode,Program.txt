1.Two Sum 

Algorithm:

1.Start with the first number in the array.

2.Go through each number after it.

3.Add the two numbers.

4.If the sum equals the target, return their positions (indexes).

5.If not, continue checking.

6.If you reach the end without finding a match, say "no pair found".



Pseudocode:

for i from 0 to n-1:
    for j from i+1 to n-1:
        if arr[i] + arr[j] == target:
            return i, j


C Code:

#include <stdio.h>

void twoSum(int arr[], int n, int target) {
    for(int i = 0; i < n; i++) {
        for(int j = i+1; j < n; j++) {
            if(arr[i] + arr[j] == target) {
                printf("Indices: %d and %d\n", i, j);
                return;
            }
        }
    }
    printf("No two sum solution found\n");
}


2.Binary Search

Algorithm:

1.Set low to the first index (0), and high to the last index.

2.Find the middle index → (low + high) / 2.

3.If the middle number is the target, return the index.

4.If the target is smaller than the middle number:

  -Look in the left half (set high = mid - 1).

5.If the target is larger:

  -Look in the right half (set low = mid + 1).

6.Repeat until low > high.

7.If the number is not found, return -1.

Pseudocode:

low = 0
high = n - 1
while low <= high:
    mid = (low + high) / 2
    if arr[mid] == target:
        return mid
    else if arr[mid] < target:
        low = mid + 1
    else:
        high = mid - 1

C Code

#include <stdio.h>

int binarySearch(int arr[], int n, int target) {
    int low = 0, high = n - 1;
    while(low <= high) {
        int mid = (low + high) / 2;
        if(arr[mid] == target)
            return mid;
        else if(arr[mid] < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}


3.Anagram Check

Algorithm:

1.First, check if both strings are the same length.

  -If not, they can't be anagrams → return false.

2.Create an array of size 256 (for ASCII characters) and set all values to 0.

3.For each character in the first string, increase its count.

4.For each character in the second string, decrease its count.

5.If all counts are 0, the strings are anagrams → return true.

6.If any count is not 0 → return false.

Pseudocode:

If length(s1) != length(s2): return false
Initialize count[256] = {0}
for each char in s1: count[char]++
for each char in s2: count[char]--
if any count[i] != 0: return false
return true

C Code:

#include <stdio.h>
#include <string.h>
#include <stdbool.h>

bool isAnagram(char *s1, char *s2) {
    if(strlen(s1) != strlen(s2))
        return false;
    
    int count[256] = {0};
    for(int i = 0; s1[i]; i++) {
        count[(unsigned char)s1[i]]++;
        count[(unsigned char)s2[i]]--;
    }

    for(int i = 0; i < 256; i++) {
        if(count[i] != 0)
            return false;
    }

    return true;
}


4.Longest Substring Without Repeating Characters

Algorithm:

1.Create an array to remember where each character was last seen.

2.Start from the beginning of the string.

3.Keep a start pointer where the current substring starts.

4.For every character:

  -If it was seen before after the current start:

    -Move start to the next of the previous position.

  -Otherwise, continue.

5.Update the maximum length after each step.

Pseudocode:

start = 0, maxLen = 0
map[256] = {-1}
for end from 0 to n-1:
    if map[s[end]] >= start:
        start = map[s[end]] + 1
    map[s[end]] = end
    maxLen = max(maxLen, end - start + 1)


C Code:

#include <stdio.h>
#include <string.h>

int longestUniqueSubstring(char *s) {
    int lastIndex[256];
    for(int i = 0; i < 256; i++) lastIndex[i] = -1;

    int maxLen = 0, start = 0;
    for(int i = 0; s[i]; i++) {
        if(lastIndex[(unsigned char)s[i]] >= start)
            start = lastIndex[(unsigned char)s[i]] + 1;
        lastIndex[(unsigned char)s[i]] = i;
        if(i - start + 1 > maxLen)
            maxLen = i - start + 1;
    }
    return maxLen;
}


5.Count Palindromic Substrings

Algorithm:

1.A palindrome reads the same forwards and backwards.

2.For each letter in the string, do two checks:

  -Check all palindromes with odd length (centered at the letter).

  -Check all palindromes with even length (centered between letters).

3.For each center:

  -Expand outwards to left and right as long as both letters are equal.

  -For each match, increase the count.

4.After checking all centers, return the total count.

Pseudocode:

for center from 0 to 2n-1:
    left = center / 2
    right = left + center % 2
    while left >= 0 and right < n and s[left] == s[right]:
        count++
        left--
        right++

C Code:

#include <stdio.h>
#include <string.h>

int countPalindromicSubstrings(char *s) {
    int n = strlen(s), count = 0;
    for(int center = 0; center < 2 * n - 1; center++) {
        int left = center / 2;
        int right = left + center % 2;
        while(left >= 0 && right < n && s[left] == s[right]) {
            count++;
            left--;
            right++;
        }
    }
    return count;
}